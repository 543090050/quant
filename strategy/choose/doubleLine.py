# -*- coding: UTF-8 -*-"""@作者: 石雨风@时间: 2020/12/20@功能： 均线选股 - 买入/卖出"""import loggingimport numpy as npimport pandas as pdfrom common.Context import Contextfrom util import dataUtil, msgUtillogging.basicConfig(level=logging.INFO,                    format='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s')def get_context():    try:        context = Context()    except IndexError:        context = Context()    return contextdef get_stocks_info():    """    从h5文件中读取数据，包括股票基本信息、信号标志、已发送消息标志    :return: df    """    try:        stocks_info = dataUtil.get_stocks_info_from_h5()    except (FileNotFoundError, KeyError):        # 解锁h5_lock，防止锁一直被占用，导致程序卡死        dataUtil.h5_lock.release()  # 解锁        stocks_info = dataUtil.init_stocks_info()    return stocks_infodef update_base_info(stocks_info, current_data_df, code):    current_data = current_data_df.loc[dataUtil.get_short_code(code)]  # 根据code从df中获取Series    stocks_info.loc[code, '股票名称'] = current_data['股票名称']    stocks_info.loc[code, '开盘价'] = current_data['开盘价']    stocks_info.loc[code, '昨收'] = current_data['昨收']    stocks_info.loc[code, '最新价'] = current_data['最新价']    stocks_info.loc[code, '最高价'] = current_data['最高价']    stocks_info.loc[code, '最低价'] = current_data['最低价']    stocks_info.loc[code, '成交手数'] = current_data['成交手数']    stocks_info.loc[code, '成交金额'] = current_data['成交金额']    stocks_info.loc[code, '最新时间'] = current_data['最新时间']    return stocks_info.loc[code]def strategy_ma8(code, stocks_info, current_data, history_data):    msg = ''    ma8 = history_data['close'][-8:].mean()    stocks_info.loc[code, 'ma8'] = ma8    pre_value = current_data['昨收']    last_value = current_data['最新价']    try:        ma8_flag = stocks_info.loc[code]['ma8_flag']    except KeyError:        stocks_info['ma8_flag'] = 'NaN'        ma8_flag = stocks_info.loc[code]['ma8_flag']    # 执行校验 跌破8    if pre_value > ma8 > last_value:        if ma8_flag != 'True':            msg = code + "跌破8日均线出现死叉;"            logging.info(msg)            stocks_info.loc[code, 'ma8_flag'] = 'True'            dataUtil.put_h5_data("stocks_info", stocks_info)    return msgdef strategy_ma30(code, stocks_info, current_data, history_data):    msg = ''    ma30 = history_data['close'].mean()    stocks_info.loc[code, 'ma30'] = ma30    pre_value = current_data['昨收']    last_value = current_data['最新价']    try:        ma30_flag = stocks_info.loc[code]['ma30_flag']    except KeyError:        # 没有找到此列，则新建列        stocks_info['ma30_flag'] = 'NaN'        ma30_flag = stocks_info.loc[code]['ma30_flag']    # 执行校验 冲破30 跌破8    if pre_value < ma30 < last_value:        if ma30_flag != 'True':            msg = code + "冲破30日均线出现金叉;"            logging.info(msg)            stocks_info.loc[code, 'ma30_flag'] = 'True'            dataUtil.put_h5_data("stocks_info", stocks_info)    return msgdef handle_data():    context = get_context()    stocks_info = get_stocks_info()    # all_code_list = dataUtil.get_sample_stocks('all')['code']    # all_code_list = dataUtil.get_sample_stocks('hs300')['code']    # all_code_list = dataUtil.get_sample_stocks('sz50')['code']    all_code_list = pd.Series(['sh.600036'])    chunk_len = 51    # 将全部code按每组chunk_len个进行分组    for code_list in np.array_split(all_code_list, len(all_code_list) / chunk_len + 1):        # 发送的QQ消息        msg = ""        short_code_list = code_list.apply(dataUtil.get_short_code)        # 获取当前价格        current_data_df = dataUtil.get_current_data(short_code_list)        # 遍历每个小组内的code        # 第一次遍历生成信号        for code in zip(code_list):            code = code[0]            # 获取历史价格            history_data = dataUtil.attribute_history(context, code, 30)            try:                # 更新基本信息                current_data = update_base_info(stocks_info, current_data_df, code)            except KeyError:                logging.error("未查询到" + code + "今日的实时价格")                continue            # 执行策略            strategy_ma30(code, stocks_info, current_data, history_data)            strategy_ma8(code, stocks_info, current_data, history_data)            # 判断信号，并发送消息            gold_flag = stocks_info.loc[code, 'gold_flag']            if gold_flag != 'sended' and stocks_info.loc[code, 'ma30_flag'] == 'True':                msg = code + "符合买入策略"                logging.info(msg)                stocks_info.loc[code, 'gold_flag'] = 'sended'                try:                    msgUtil.sendMsg(msg)                    # 保存h5文件，记录消息标志位，目的是一天只发送一次符合条件的消息                    dataUtil.put_h5_data("stocks_info", stocks_info)                except Exception as e:                    logging.error(e)            dead_flag = stocks_info.loc[code, 'dead_flag']            if dead_flag != 'sended' and stocks_info.loc[code, 'ma8_flag'] == 'True':                msg = code + "符合卖出策略"                logging.info(msg)                stocks_info.loc[code, 'dead_flag'] = 'sended'                try:                    msgUtil.sendMsg(msg)                    # 保存h5文件，记录消息标志位，目的是一天只发送一次符合条件的消息                    dataUtil.put_h5_data("stocks_info", stocks_info)                except Exception as e:                    logging.error(e)        # 第二次遍历发送消息        # for code in zip(code_list):        # 发送qq数据        # if len(msg) > 0:        #     try:        #         msgUtil.sendMsg(msg)        #         # 保存h5文件，记录消息标志位，目的是一天只发送一次符合条件的消息        #         dataUtil.put_h5_data("stocks_info", stocks_info)        #     except Exception as e:        #         logging.error(e)# handle_data()# if __name__ == '__main__':#     while 1:#         # if timeUtil.in_trade_time():#         if timeUtil.in_trade_time(time1='9:00', time2='23:00'):#             handle_data()